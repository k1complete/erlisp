-module(operators_test).

-include_lib("eunit/include/eunit.hrl").
-include_lib("syntax_tools/include/merl.hrl").

problem_list() ->
    [
     #{src => "(+ 1)",
       var => [],
       result => {value, 1, []}},
     #{src => "(- 1)",
       var => [],
       result => {value, -1, []}},
     #{src => "(+ 1 1)",
       var => [],
       result => {value, 2, []}},
     #{src => "(- 1 1)",
       var => [],
       result => {value, 0, []}},
     #{src => "(* 3 4)",
       var => [],
       result => {value, 12, []}},
     #{src => "(/ 3 4)",
       var => [],
       result => {value, 0.75, []}},
     #{src => "(bnot 1)",
       var => [],
       result => {value, -2, []}},
     #{src => "(div 13 4)",
       var => [],
       result => {value, 3, []}},
     #{src => "(rem 13 4)",
       var => [],
       result => {value, 1, []}},
     #{src => "(band 13 6)",
       var => [],
       result => {value, 4, []}},
     #{src => "(bor 13 6)",
       var => [],
       result => {value, 15, []}},
     #{src => "(bxor 13 6)",
       var => [],
       result => {value, 11, []}},
     #{src => "(bsl 8 1)",
       var => [],
       result => {value, 16, []}},
     #{src => "(bsr 16 1)",
       var => [],
       result => {value, 8, []}},
     #{src => "(not 'true)",
       var => [],
       result => {value, false, []}},
     #{src => "(and 'true 'false)",
       var => [],
       result => {value, false, []}},
     #{src => "(or 'true 'false)",
       var => [],
       result => {value, true, []}},
     #{src => "(xor 'true 'true)",
       var => [],
       result => {value, false, []}},
     #{src => "(orelse 'true 'false)",
       var => [],
       result => {value, true, []}},
     #{src => "(andalso 'true 'true)",
       var => [],
       result => {value, true, []}},
     #{src => "(++ (list 1 2 3) (list 4 5))",
       var => [],
       result => {value, [1,2,3,4,5], []}},
     #{src => "(-- (list 1 2 3 2 1 2) (list 2 1 2))",
       var => [],
       result => {value, [3,1,2], []}}
    ].
operators_test() ->
    Line = ?LINE,
    lists:map(fun(L) ->
		      io:format("KKKK ~p~n", [L]),
		      Cmd = maps:get(src, L),
		      Result = maps:get(result, L),
		      Var = maps:get(var, L),
		      Binding = lists:foldr(fun({K, V}, A) ->
						    erl_eval:add_bindings(K, V, A)
					    end, erl_eval:new_bindings(),
					    Var),
		      {ok, Tokens, _Line} = els_scan:from_string(lists:flatten(Cmd), Line),
		      io:format("tokens ~p~n", [Tokens]),
		      {ok, [Tree]} =els_parser:parse(Tokens),
		      C = els_transpile:form(Tree, []),
		      io:format("TransForm ~p~n", [erl_syntax:revert(C)]),
		      ?assertEqual(Result,
				   erl_eval:expr(erl_syntax:revert(C), Binding))
	      end, problem_list()).
