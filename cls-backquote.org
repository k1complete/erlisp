 2.4.6 Backquote

The backquote introduces a template of a data structure to be built. For example, writing

 `(cond ((numberp ,x) ,@y) (t (print ,x) ,@y))

is roughly equivalent to writing

 (list 'cond 
       (cons (list 'numberp x) y) 
       (list* 't (list 'print x) y))

Where a comma occurs in the template, the expression following the comma is to be evaluated to produce an object to be inserted at that point. Assume b has the value 3, for example, then evaluating the form denoted by `(a b ,b ,(+ b 1) b) produces the result (a b 3 4 b).


2.4.6 バッククォート

逆引用符は、構築するデータ構造のテンプレートを導入します。 たとえば、

  `(cond ((numberp ,x) ,@y) (t (print ,x) ,@y))

書くこととほぼ同じです

  (list 'cond
        (cons (list 'numberp x) y)
        (list* 't (list 'print x) y))

テンプレート内でコンマが発生する場合、コンマに続く式が評価され、その時
点に挿入されるオブジェクトが生成されます。 たとえば、b の値が 3 である
と仮定すると、`(a b ,b ,(+ b 1) b) で表される形式を評価すると、結果 (a
b 3 4 b) が生成されます。

 If a comma is immediately followed by an at-sign, then the form following the at-sign is evaluated to produce a list of objects. These objects are then ``spliced'' into place in the template. For example, if x has the value (a b c), then

 `(x ,x ,@x foo ,(cadr x) bar ,(cdr x) baz ,@(cdr x))
=>  (x (a b c) a b c foo b bar (b c) baz b c)

The backquote syntax can be summarized formally as follows.

コンマの直後にアットマークが続く場合、アットマークに続くフォームが評価
され、オブジェクトのリストが生成されます。 これらのオブジェクトは、テ
ンプレート内の所定の位置に「接合」されます。 たとえば、x の値が (a b
c) の場合、

  `(x ,x ,@x foo ,(cadr x) bar ,(cdr x) baz ,@(cdr x))
=> (x (ab c) a b c foo b バー (bc) baz b c)

逆引用符の構文は、次のように形式的に要約できます。

- `basic is the same as 'basic, that is, (quote basic), for any expression basic that is not a list or a general vector.

- `,form is the same as form, for any form, provided that the representation of form does not begin with at-sign or dot. (A similar caveat holds for all occurrences of a form after a comma.)

- `,@form has undefined consequences.

- `(x1 x2 x3 ... xn . atom) may be interpreted to mean

     (append [ x1] [ x2] [ x3] ... [ xn] (quote atom))

    where the brackets are used to indicate a transformation of an xj as follows:

    -- [form] is interpreted as (list `form), which contains a backquoted form that must then be further interpreted.

    -- [,form] is interpreted as (list form).

    -- [,@form] is interpreted as form.

- `(x1 x2 x3 ... xn) may be interpreted to mean the same as the backquoted form `(x1 x2 x3 ... xn . nil), thereby reducing it to the previous case.

- `(x1 x2 x3 ... xn . ,form) may be interpreted to mean

     (append [ x1] [ x2] [ x3] ... [ xn] form)

    where the brackets indicate a transformation of an xj as described above.

- `(x1 x2 x3 ... xn . ,@form) has undefined consequences.

- `#(x1 x2 x3 ... xn) may be interpreted to mean (apply #'vector `(x1 x2 x3 ... xn)).



- `basic は 'basic と同じです。つまり、リストでも一般的なベクトルでも
  ない任意の式 basic については (quote basic) です。

- `,form は、フォームの表現がアットマークまたはドットで始まらない限り、
  formと同じです。 (カンマの後のフォームのすべての出現についても同
  様の注意が必要です。)

- `,@form には未定義の結果があります。

- `(x1 x2 x3 ... xn . atom) は、

     (append [ x1] [ x2] [ x3] ... [ xn] (quote atom))

    ここで、角かっこは、次のように xj の変換を示すために使用されます。

  -- [form] は (list `form) として解釈されます。これには、バッククォー
  トで囲まれたフォームが含まれており、さらに解釈する必要があります。

  -- [,form] は (list form) と解釈されます。

  -- [,@form] は form として解釈されます。

-  `(x1 x2 x3 ... xn) は、逆引用符で囲まれた形式の `(x1 x2 x3 ... xn
  . nil) と同じ意味であると解釈される場合があるため、前のケースに縮小
  されます。

- `(x1 x2 x3 ... xn . ,form) は、

  (append [ x1] [ x2] [ x3] ... [ xn] form)

    ここで、括弧は上記の xj の変換を示します。

- `(x1 x2 x3 ... xn . ,@form) の結果は未定義です。

- `#(x1 x2 x3 ... xn) は (apply #'vector `(x1 x2 x3 ... xn) ) という意
  味に解釈される場合があります。

 Anywhere ``,@'' may be used, the syntax ``,.'' may be used instead to indicate that it is permissible to operate destructively on the list structure produced by the form following the ``,.'' (in effect, to use nconc instead of append).

If the backquote syntax is nested, the innermost backquoted form should be expanded first. This means that if several commas occur in a row, the leftmost one belongs to the innermost backquote. ]

どこでも「,@」を使用できますが、代わりに構文「,.」を使用して、「,.」に
続く形式によって生成されるリスト構造に対して破壊的な操作が許容されるこ
とを示すことができます ( append の代わりに nconc を使用します)。

逆引用符の構文がネストされている場合は、最も内側の逆引用符で囲まれた形
式を最初に展開する必要があります。 これは、複数のコンマが連続して発生
する場合、最も左のコンマが最も内側の逆引用符に属することを意味します。

An implementation is free to interpret a backquoted form F1 as any form F2 that, when evaluated, will produce a result that is the same under equal as the result implied by the above definition, provided that the side-effect behavior of the substitute form F2 is also consistent with the description given above. The constructed copy of the template might or might not share list structure with the template itself. As an example, the above definition implies that

実装は、逆引用符で囲まれたフォーム F1 を任意のフォーム F2 として自由に
解釈できます。フォーム F2 は、評価されると、上記の定義によって暗示され
た結果と同じまたは同等以下の結果を生成します。ただし、代替フォーム F2
の副作用の動作が も上記の説明と一致します。 テンプレートの構築されたコ
ピーは、リスト構造をテンプレート自体と共有する場合と共有しない場合があ
ります。 例として、上記の定義は次のことを意味します。

 `((,a b) ,c ,@d)

will be interpreted as if it were

 (append (list (append (list a) (list 'b) 'nil)) (list c) d 'nil)

but it could also be legitimately interpreted to mean any of the following:

 (append (list (append (list a) (list 'b))) (list c) d)
 (append (list (append (list a) '(b))) (list c) d)
 (list* (cons a '(b)) c d)
 (list* (cons a (list 'b)) c d)
 (append (list (cons a '(b))) (list c) d)

 `((,a b) ,c ,@d)

は以下であるかのように解釈されます。

 (append (list (append (list a) (list 'b) 'nil)) (list c) d 'nil)

ただし、次のいずれかを意味すると正当に解釈されることもあります。

  (append (list (append (list a) (list 'b))) (list c) d)
  (append (list (append (list a) '(b))) (list c) d)
  (list* (cons a '(b)) c d)
  (list* (cons a (list 'b)) c d)
  (append (list (cons a '(b))) (list c) d)

 2.4.6.1 Notes about Backquote

Since the exact manner in which the Lisp reader will parse an expression involving the backquote reader macro is not specified, an implementation is free to choose any representation that preserves the semantics described.

Often an implementation will choose a representation that facilitates pretty printing of the expression, so that (pprint `(a ,b)) will display `(a ,b) and not, for example, (list 'a b). However, this is not a requirement.

Implementors who have no particular reason to make one choice or another might wish to refer to IEEE Standard for the Scheme Programming Language, which identifies a popular choice of representation for such expressions that might provide useful to be useful compatibility for some user communities. There is no requirement, however, that any conforming implementation use this particular representation. This information is provided merely for cross-reference purposes.

2.4.6.1 バッククォートに関する注意事項

バッククォート リーダー マクロを含む式を Lisp リーダーが解析する正確な
方法は指定されていないため、実装では、記述されたセマンティクスを保持す
る任意の表現を自由に選択できます。

多くの場合、実装は式のきれいな印刷を容易にする表現を選択するため、
(pprint `(a ,b)) は `(a ,b) を表示し、たとえば (list 'a b) は表示しま
せん。 ただし、これは必須ではありません。

どちらかを選択する特別な理由がない実装者は、Scheme プログラミング言語
の IEEE 標準を参照することをお勧めします。これは、一部のユーザー コミュ
ニティにとって有用な互換性を提供する可能性のある式の表現の一般的な選択
肢を特定するものです。 ただし、準拠する実装がこの特定の表現を使用する
必要はありません。 この情報は、相互参照のみを目的として提供されていま
す。

